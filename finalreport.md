# Group 3: Pointy - Final Report



# Peer Review

## General remarks
The code was often simple to read but  took some time to understand due to a lack of documentation and a comprehensive design model. However, the code had some issues, which we’d like to address here.
First of all, the model (`QuizModel`) lacks some functionality, which is instead placed in the class `StandardQuizViewModel`. For example, the methods `answerQuestion`, `createAlternativeList`	 and fields such as `totalQuestions`, `correctAnswers` and `questionProvider` could be contained within the model with the appropriate methods added to the model interface (`IQuestionHandler`). This would increase the separation between the view and the model. This separation is currently fairly limited, or at least unclear.

Sometimes, the design patterns used, or how they are implemented, strike us as contrived. For example, all your model observers only implement one method (`quizFinished`), and don't handle any events. Any model observer could therefore only listen to one type of action, which is not extensible. This breaks both DIP and OCP. Polling could easily be used, especially since the `StandardQuizViewModel` subscribes as an observer to one of its own fields (`questionHandler`).

The use of the iterator pattern is questionable. All IQuestions have an iterator which iterates over the question alternatives, however this iterator is most often later converted to a list, for example in `createAlternativeList` in `StandardQuizViewModel` (in this case, this list is also later converted to a list of tuples, which is unnecessarily complex). We found the same issue in `QuizModel`. Often, the iterator pattern does not aid your model, it just makes things more complicated. Consider if other data structures, for example sets or maps are more suitable. (You don't have to implement a list iterator on your own, since all java lists have an `iterator` method which returns an iterator for that list.)

Factory classes are often used, which is good for extensibility and modularity, however most of your factories only implement a single method or perform fairly simple operations. For example, `createStandardModel` in `ModelFactory` could just be a constructor call (if `QuizModel` takes the iterator of questions in its constructor instead of using the `insertQuestions` method). 

There are some other small issues sprinkled around the code too. For example, `setBaseQuestion` in `ScrambledQuestion` is used instead of a constructor call. This method does nothing if it has been called before, which is unintuitive, especially when calling this functionality easily could be disallowed by using a constructor call instead. 

The name of `QuestionsFromFile` doesn't actually read from a file. The implementation for generating random math questions is also a bit strange. Wrong alternatives are generated by adding the two numbers together, and then adding a random value. Why not just randomly generate a wrong alternative (and retry if it ends up being correct, by chance)? 

Your tuples should be more descriptive. Instead of creating a general tuple class, create a more descriptive class (for example, “Alternatives”) with fields actually describing the intended contents of the class.

The code uses switch statements at several places which could make it hard to extend and maintain. There is also duplicated code at some places, for example the constructor of `StandardQuizModel` and `changeQuestion`, as well as `getQuestion` and `nextQuestion`.

## Structure and Documentation
The System Design in the SDD doesn’t seem to correctly reflect the project. The diagram shows “QuizModel'' being a package but in the project it’s called “QuizPackage”. There is no designmodel or other detailed UML-diagrams in the SDD or RAD which creates difficulties in overlooking and understanding the project. It is also hard to see how the domain model relates to the code. “User” exists in the domain model but doesn't seem to have any corresponding component in the code.

The project could make use of a more solid package structure, for example in activities, modalFragment and RecyclerViewAdapter.

We generally find that the code is lacking in comments, at least to make it understandable for anyone not already familiar with the project. Several classes do not contain descriptions of what they are or what they do. Likewise, comments pertaining to methods are quite often vague and only useful for someone who’s already well acquainted with the code. 

## Style and conventions
The style and naming used in the code is varying and often doesn’t follow convention. Here are a few small notes: Many interface methods are unnecessarily prefaced with “public”, as seen in the `IViewModel`. The modal field in `MainActivity` is not private when it should be. Some methods suffer from strange formatting, such as `onCreate` in `SettingsActivity`. And the `CountDown` method in `QuizActivity` is capitalized when it shouldn’t be. The opposite could be said for your package names: java packages should not be capitalized. 

Many variables are also poorly named. The name of “tupleList” should reflect the contents of the list. “observerList” could just be “observers”, “questionStack” could just be “questions”, and so on.

## Testing
You have a good amount of tests, however some are odd. For example, `QuestionFactoryTest` only tests if a returned object has the "correct" type. There's also an example-test left in the code.
Final thoughts
You have a good idea, and what you describe in your SDD seems good. The described structure is good and makes sure you can separate model and view, even though android application enforces the use of certain classes. However, your code doesn't exactly match your descriptions or your domain model. Hopefully our suggestions will be of good use, and help you build an even better application.

Good luck!


